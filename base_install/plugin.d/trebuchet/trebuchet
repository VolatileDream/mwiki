#!/usr/bin/env python3

from collections import defaultdict
from configparser import ConfigParser
from copy import copy
from datetime import datetime
import enum
import os
import subprocess

class Parser(object):

  def __init__(self, cfg):
    self.init = False
    self.config = cfg

  def create_from(self, fileio=None, string=None, string_iterator=None):
    """
    Given either: a file, string, or iterator containing strings, builds
    and returns a Trebuchet object.
    """
    not_none=0
    if fileio is not None:
      not_none += 1
    if string is not None:
      not_none += 1
    if string_iterator is not None:
      not_none += 1
    if not_none != 1:
      raise Exception("createFrom called with too many arguments!")

    if fileio:
      return self.create_from(string_iterator=strip_terminal_newline(fileio.readlines()))
    if string:
      return self.create_from(string_iterator=string.split("\n"))

    # Hold a permanent reference to the root. The root is special, and has -1
    # indent, to ensure that no other item could possibly have indent equal to
    # it.
    root = RockNode(indent=-1, line="", config=self.config)

    # The stack of parent Trebuchet items.
    stack = [root]
    for line in string_iterator:
      glyph, has_indent = self.__starting_glyph(line)
      if not glyph:
        if line.strip():
          raise Exception("No glyph specified for: %s" % line)
        else:
          # empty line.
          has_indent=False
          indent = 0
      else:
        if not has_indent:
          line = line.strip()
          indent = 0
        else:
          indent = count_starting_whitespace(line)

      current = RockNode(indent=indent, line=line, glyph=glyph, config=self.config)

      # this item may need to be placed into the list properly.
      if not has_indent:
        # reset the stack, this item is appended to the root.
        root.add_child(current)
        stack = [root]
      else:
        # this item obeys indent rules. Attempt to get it into the list.
        parent = None
        while True:
          parent = stack[-1]
          if indent <= parent.indent:
            stack.pop()
          else:
            break
        parent.add_child(current)
        # Assume the next item is beneath this one. If it's not, this will
        # get popped off the stack immediately.
        stack.append(current)

    return root

  def __starting_glyph(self, line):
    line = line.lstrip()
    for key in self.config.glyphs:
      # checks if the line is the glyph, as some cases (the progress/done
      # delimiter) will not have anything after the glyph. Lines that start
      # with a glyph not followed by whitespace are technically errors.
      if line.startswith(key + " ") or line == key:
        return (key, key != self.config.delimiter)
    return None, None


class RockNode(object):
  
  def __init__(self, indent=0, line=None, glyph=None, children=None, config=None):
    self.indent = indent
    self.line = line
    self.glyph = glyph
    self.children = children
    if self.children is None:
      self.children = []
    self.config = config

  def __copy__(self, indent=None, line=None, glyph=None, children=None):
    """
    Implement functionality to use copy.copy, but also
    provide an easy mechanism to change some subfields.
    """
    copy = RockNode(
        indent=self.indent,
        line=self.line,
        glyph=self.glyph,
        children=self.children,
        config=self.config)
    if indent is not None:
      copy.indent = indent
    if line is not None:
      copy.line = line
    if glyph is not None:
      copy.glyph = glyph
    if children is not None:
      copy.children = children

    return copy

  def add_child(self, child):
    self.children.append(child)

  def reorder(self, ordering=None):
    """
    Takes a list of glyphs and returns a reordered trebuchet instance.
    """
    if ordering is None:
      ordering = self.config.glyphs
    glyph_set = set(ordering).symmetric_difference(self.config.glyphs)
    if len(glyph_set) > 0:
      raise Exception(
          "Not all glyphs present in reordering!"
          " reorder must be called with all glyphs from initialization."
          " %s vs %s" % (ordering, self.config.glyphs))
    return self.__reorder(ordering)

  def __reorder(self, ordering):
    reordered_children = defaultdict(lambda: list())
    for child in self.children:
      reordered_children[child.glyph].append(child.__reorder(ordering))
    new_children = []
    for glyph in ordering:
      new_children.extend(reordered_children[glyph])
    return self.__copy__(children=new_children)

  def filter(self, filterfn):
    """
    Accepts a Glpyh predicate function.

    Filters out nodes that do not match the filter, is applied recursively.

    Returns a new Trebuchet instance with the filtering applied.
    """
    # The glyph for this node was checked by its parent, only filter children.
    # Convenient side effect -> root is never checked.
    new_children = []
    for c in self.children:
      if filterfn(c.glyph):
        new_children.append(c.filter(filterfn))
    return self.__copy__(children=new_children)

  def str(self):
    children_repr = "".join([c.str() for c in self.children])
    newline = "\n"
    if self.indent == -1:
      # don't add an extra newline for the root element.
      newline = ""
    return self.line + newline + children_repr


class TrebuchetConfig(object):

  def __init__(self, glyphs, done_glyphs, delim, intervals=None, intervals_dict=None):
    self._glyphs = glyphs
    self._done_glyphs = done_glyphs
    self._delimiter = delim
    self._intervals = intervals
    self._intervals_dict = intervals_dict
    if self._delimiter not in self.glyphs:
      raise Exception("Delimiter must be specified in glyph list!")

  @property
  def done_glyphs(self):
    return self._done_glyphs

  @property
  def glyphs(self):
    """
    Returns all the glyphs used, in the order they should be sorted.
    """
    return self._glyphs

  @property
  def delimiter(self):
    return self._delimiter

  def intervals(self):
    return list(self._intervals)

  def interval(self, interval_name):
    return self._intervals_dict[interval_name]

  @staticmethod
  def from_ini(filename):
    cfg = ConfigParser()
    cfg.read([filename])
    
    delim = cfg.get("trebuchet", "glyphs.delimiter")
    done_glyphs = cfg.get("trebuchet", "glyphs.done").split(",")

    items = []
    items.extend(cfg.get("trebuchet", "glyphs.in_progress").split(","))
    items.append(delim)
    items.extend(done_glyphs)

    intervals = {}
    interval_keys = cfg.get("trebuchet", "intervals").split(",")
    bad_intervals = [ r for r in interval_keys if not r.startswith("intervals.")]
    if len(bad_intervals) > 0:
      raise Exception("Found improperly named intervals: %s" % bad_intervals)
    for interval in interval_keys:
      intervals[interval] = cfg.get("trebuchet", interval, raw=True)

    return TrebuchetConfig(
        glyphs=items,
        done_glyphs=done_glyphs,
        delim=delim,
        intervals=interval_keys,
        intervals_dict=intervals)


class Interval(object):
  """
  Storage encapsulation for the interval, enabling easy status checking.
  """

  def __init__(self, name, time_format, time_provider=None, watermark=None):
    """
    Create an interval.
      name:
          - the (descriptive) name for the interval, sets of intervals are
            usually required to have unique names.
          - also used for file io
      time_format:
          - a time format usable by datetime.strftime
      time_provider:
          - function that returns a datetime object, when given no arguments
      watermark:
          - an optional WatermarkFile object to use, rather than generating one with `name`
    """
    self.name = name
    self.time_format = time_format
    if time_provider is None:
      time_provider = datetime.now
    self.time_provider = time_provider
    if watermark is None:
      watermark = WatermarkFile(name + "-last", name + "-content")
    self.watermark = watermark

  def __current(self):
    return self.time_provider().strftime(self.time_format)

  def last(self):
    return self.watermark.last()
 
  def can_update(self):
    return self.__current() != self.watermark.last()

  def update(self):
    self.watermark.update(self.__current())

  def content_handle(self):
    return self.watermark.content_filehandle()


class WatermarkFile(object):
  """
  Class to provide a high watermark of sorts with two files.
  One provides content, the other the monotonic watermark.

  Expected operation order:

  init(mark, content)
  if last() != current_watermark() and has_content():
    with content_filehandle() as file:
      process(file)
    update(current_watermark())

  This assumes the user has some `current_watermark` function.
  """

  def __init__(self, mark_name, content_name):
    self.mark = mark_name
    self.content = content_name

  def last(self):
    """
    Returns the last watermark, or None.
    """
    try:
      with open(self.mark) as file:
        return file.readline().strip()
    except FileNotFoundError:
      return None

  def has_content(self):
    """
    Returns true if the last watermark has content.
    """
    try:
      return os.stat(self.content).st_size > 0
    except FileNotFoundError:
      return False

  def content_filehandle(self):
    """
    Returns an open file object to the content file.

    Is both readable and writeable in byte mode.
    """
    return open(self.content, "r+")

  def update(self, next):
    try:
      os.truncate(self.content, 0)
    except FileNotFoundError:
      pass
    with open(self.mark, "w") as file:
      file.write(next)
      file.write("\n") # be nice to text editors

class TrebuchetApp(object):

  def __init__(self, config, fixed_time=None):
    self.config = config
    self.loaded = {}
    if fixed_time is None:
      self.fixed_time = None
    else:
      self.fixed_time = lambda: fixed_time
    pass # ???

  def prompt(self, _arg1, _arg2):
    if self.fixed_time:
      print(self.fixed_time())
    else:
      print("none")

  def todo(self, interval_name):
    pass

  def edit(self, interval_name):
    self.update(interval_name, prompt=True)
    os.spawnlp(os.P_WAIT, "sensible-editor", "sensible-editor", interval_name + "-content")

  def update(self, interval_name, prompt=False):
    interval = self.__interval(interval_name)
    trebuchet = None # declare at more recent scope
    
    if interval.can_update():
      if prompt:
        response = input("An entry already exists for %s, commit? (y/N) " % interval_name)
        if response != "Y" and response != "y":
          return
      trebuchet = self.__content(interval)

      # Compute the new trebuchet
      trebuchet = self.advance_trebuchet(trebuchet)
      write_to_wiki(interval.last(), trebuchet)

    interval.update()

    if trebuchet:
      # Now prep the trebuchet for the next iteration, keep everything before the delimiter.
      trebuchet = trebuchet.filter(latch(lambda glyph: glyph != self.config.delimiter))
      with interval.content_handle() as file:
        file.write(trebuchet.str())
    pass

  def load(self, interval_name):
    return self.__content(self.__interval(interval_name))

  def __interval(self, interval_name):
    if interval_name not in self.config.intervals():
      raise Exception("No such interval: %s" % interval_name)
    if interval_name not in self.loaded:
      self.loaded[interval_name] = Interval(
          interval_name,
          self.config.interval(interval_name),
          self.fixed_time)
    return self.loaded[interval_name]

  def __content(self, interval):
    """Load content from an interval"""
    with interval.content_handle() as file:
      parser = Parser(self.config)
      return parser.create_from(fileio=file)

  def advance_trebuchet(self, node):
    # First reorder the node, then perform complex filtering.
    root = node.reorder(self.config.glyphs)
  
    new_children = [] 

    # copy items that aren't done yet.
    for current in root.children:
      if current.glyph == self.config.delimiter or current.glyph in self.config.done_glyphs:
        # items are sorted, we should see a delimiter first. Baring that, we'll
        # encounter items that are done.
        break
      # Remove items that are done using filter.
      new_children.append(current.filter(
          lambda glyph: glyph not in self.config.done_glyphs))

    # At the end of the previous loop we add a marker
    # to denote the end of the "not done" items.
    new_children.append(
        RockNode(
            indent=0,
            line=self.config.delimiter,
            glyph=self.config.delimiter,
            config=self.config))

    # now copy done items.
    for child in root.children:
      # you'd expect that here we'd only keep done items, but we actually
      # have to keep the whole tree leading up to the done things. ie, when a
      # root isn't done, but has some done sub items. We want to keep the sub
      # items. ex:
      #
      # [] not done
      #   * note
      #   [x] done
      # ---
      #
      # becomes
      #
      # [] not done
      #   * note
      # ---
      # [] not done
      #   [x] done
      #
      current = self.copy_done_items(child)
      if current:
        new_children.append(current)

    # we're going to destructively mutate, create a copy.
    root = copy(root)
    root.children = new_children
    return root

  def copy_done_items(self, node):
    # Keep items with a done glyph, and all their sub items.
    if node.glyph in self.config.done_glyphs:
      return node

    # check to see if any of the nodes children make it worth keeping.
    kept_children = []
    for child in node.children:
      copied = self.copy_done_items(child)
      if copied:
        kept_children.append(copied)

    # If this had an item we want to keep as a child, keep it as well.
    if len(kept_children) > 0:
      node = copy(node)
      node.children = kept_children
      return node
    return None


# various utilities

# TODO is there a better box type than this?
def latch(predicate):
  import functools
  result = [True]
  @functools.wraps(predicate)
  def fn(*args, **kvargs):
    r = result[0] and predicate(*args, **kvargs)
    result[0] = r
    return result[0]

  return fn
    

def count_starting_whitespace(string):
  return len(string) - len(string.lstrip()) 


def strip_terminal_newline(generator):
  for line in generator:
    yield line.rstrip("\n")


def write_to_wiki(entry_name, trebuchet):
  # Take advantage of the mwiki command.
  with subprocess.Popen(
          ["mwiki", "edit", entry_name],
          stdin=subprocess.PIPE,
          universal_newlines=True) as proc:
    proc.stdin.write(trebuchet.str())
    proc.stdin.close()

    # mwiki might be rebuilding everything...
    proc.wait()

    if proc.returncode != 0:
      raise Exception("mwiki didn't exit cleanly! Return code: %s" % proc.returncode)


def flag_parser(commands):
  import argparse
  parser = argparse.ArgumentParser()
  parser.add_argument(
      "command",
      nargs="?", # may not be present
      default=None,
      type=str,
      choices=commands,
      help="Command to run.")
  parser.add_argument(
      "--config", "-c",
      type=TrebuchetConfig.from_ini,
      help="Configuration ini file.")
  parser.add_argument(
      "--interval", "-i",
      type=lambda arg: "intervals." + arg,
      help="Interval")
  parser.add_argument(
      "--date", "-d",
      type=lambda arg: datetime.utcfromtimestamp(int(arg)),
      default=None,
      metavar="DATE",
      help="act as though time is DATE and not 'now', takes a POSIX timestamp"
          + " in UTC. The easiest way to populate this (on linux) is with:"
          + " `date --date 'TEXT' +%%s`")

  return parser


def main():
  actions = {
    "edit" : TrebuchetApp.edit,
    "update" : TrebuchetApp.update,
    "todo" : TrebuchetApp.todo,
  }
  commands_to_run = list(actions.keys())

  # Add the default action
  actions[None] = TrebuchetApp.prompt

  import sys

  args = flag_parser(commands_to_run).parse_args(sys.argv[1:])
  app = TrebuchetApp(args.config, args.date)
  actions[args.command](app, args.interval)

if __name__ == "__main__":
  main()

  # TODO figure out how commands work.

  # What's the default for edit?
  #  * Do something like `journal` which does a reasonable thing by default.
  #  * Check everything in need of updates, and then update from largest to smallest?
  #   > trebuchet
  #   The following time-spans need to be updated, which should go first?
  #     1) yearly
  #     2) monthly
  #     3) weekly
  #     4) daily
  #   (default: 1) >
  #   $ sensible-editor "$1"
  #  * Otherwise we'd have to figure out something with opening more than one
  #    file at a time, which is a pain.
  # 
  # edit [span] -> check if it needs to update, then edit it.
  # update [span] -> check if it needs to update
  #   * don't copy `journal`s behaviour here. No force updates.

  # Do multiple files need to be opened all at once?
  #  > don't really want to...
  # Maybe support time travel with --date or --time flag?
  # Updates need to be ordered to prevent funny time change things?
  #   Like when all of the year, month, and week change? -> what gets updated first?
  # This maybe only matters if there's automated "up" movement?

