#!/usr/bin/env python3

from collections import defaultdict
from configparser import ConfigParser
from copy import copy
from datetime import datetime
import enum
import os
import subprocess

class TrebuchetParser(object):

  def __init__(self, cfg):
    self.init = False
    self.config = cfg

  def create_from(self, fileio=None, string=None, string_iterator=None):
    """
    Given either: a file, string, or iterator containing strings, builds
    and returns a Trebuchet object.
    """
    not_none=0
    if fileio is not None:
      not_none += 1
    if string is not None:
      not_none += 1
    if string_iterator is not None:
      not_none += 1
    if not_none != 1:
      raise Exception("createFrom called with too many arguments!")

    if fileio:
      return self.create_from(string_iterator=strip_terminal_newline(fileio.readlines()))
    if string:
      return self.create_from(string_iterator=string.split("\n"))

    # Hold a permanent reference to the root. The root is special, and has -1
    # indent, to ensure that no other item could possibly have indent equal to
    # it.
    root = Trebuchet(indent=-1, line="", config=self.config)

    # The stack of parent Trebuchet items.
    stack = [root]
    for line in string_iterator:
      glyph, has_indent = self.__starting_glyph(line)
      if not glyph:
        if line.strip():
          raise Exception("No glyph specified for: %s" % line)
        else:
          # empty line.
          has_indent=False
          indent = 0
      else:
        if not has_indent:
          line = line.strip()
          indent = 0
        else:
          indent = count_starting_whitespace(line)

      current = Trebuchet(indent=indent, line=line, glyph=glyph, config=self.config)

      # this item may need to be placed into the list properly.
      if not has_indent:
        # reset the stack, this item is appended to the root.
        root.add_child(current)
        stack = [root]
      else:
        # this item obeys indent rules. Attempt to get it into the list.
        parent = None
        while True:
          parent = stack[-1]
          if indent <= parent.indent:
            stack.pop()
          else:
            break
        parent.add_child(current)
        # Assume the next item is beneath this one. If it's not, this will
        # get popped off the stack immediately.
        stack.append(current)

    return root

  def __starting_glyph(self, line):
    line = line.lstrip()
    for key in self.config.glyphs:
      # checks if the line is the glyph, as some cases (the progress/done
      # delimiter) will not have anything after the glyph. Lines that start
      # with a glyph not followed by whitespace are technically errors.
      if line.startswith(key + " ") or line == key:
        return (key, key != self.config.delimiter)
    return None, None


class Trebuchet(object):
  
  def __init__(self, indent=0, line=None, glyph=None, children=None, config=None):
    self.indent = indent
    self.line = line
    self.glyph = glyph
    self.children = children
    if self.children is None:
      self.children = []
    self.config = config

  def __copy__(self, indent=None, line=None, glyph=None, children=None):
    """
    Implement functionality to use copy.copy, but also
    provide an easy mechanism to change some subfields.
    """
    copy = Trebuchet(
        indent=self.indent,
        line=self.line,
        glyph=self.glyph,
        children=self.children,
        config=self.config)
    if indent is not None:
      copy.indent = indent
    if line is not None:
      copy.line = line
    if glyph is not None:
      copy.glyph = glyph
    if children is not None:
      copy.children = children

    return copy

  def add_child(self, child):
    self.children.append(child)

  def reorder(self, ordering=None):
    """
    Takes a list of glyphs and returns a reordered trebuchet instance.
    """
    if ordering is None:
      ordering = self.config.glyphs
    glyph_set = set(ordering).symmetric_difference(self.config.glyphs)
    if len(glyph_set) > 0:
      raise Exception(
          "Not all glyphs present in reordering!"
          " reorder must be called with all glyphs from initialization."
          " %s vs %s" % (ordering, self.config.glyphs))
    return self.__reorder(ordering)

  def __reorder(self, ordering):
    reordered_children = defaultdict(lambda: list())
    for child in self.children:
      reordered_children[child.glyph].append(child.__reorder(ordering))
    new_children = []
    for glyph in ordering:
      new_children.extend(reordered_children[glyph])
    return self.__copy__(children=new_children)

  def filter(self, filterfn):
    """
    Accepts a Glpyh predicate function.

    Filters out nodes that do not match the filter, is applied recursively.

    Returns a new Trebuchet instance with the filtering applied.
    """
    # The glyph for this node was checked by its parent, only filter children.
    # Convenient side effect -> root is never checked.
    new_children = []
    for c in self.children:
      if filterfn(c.glyph):
        new_children.append(c.filter(filterfn))
    return self.__copy__(children=new_children)

  def str(self):
    children_repr = "".join([c.str() for c in self.children])
    newline = "\n"
    if self.indent == -1:
      # don't add an extra newline for the root element.
      newline = ""
    return self.line + newline + children_repr

  def __repr__(self):
    children_repr = ",".join([repr(c) for c in self.children])
    newline = ""
    return "Trebuchet(line='" + self.line +"', children=[" + children_repr + "])"


class TrebuchetConfig(object):

  def __init__(self, glyphs, done_glyphs, delim, rocks=None, rocks_dict=None):
    self._glyphs = glyphs
    self._done_glyphs = done_glyphs
    self._delimiter = delim
    self._rocks = rocks
    self._rocks_dict = rocks_dict
    if self._delimiter not in self.glyphs:
      raise Exception("Delimiter must be specified in glyph list!")

  @property
  def done_glyphs(self):
    return self._done_glyphs

  @property
  def glyphs(self):
    """
    Returns all the glyphs used, in the order they should be sorted.
    """
    return self._glyphs

  @property
  def delimiter(self):
    return self._delimiter

  def rocks(self):
    return list(self._rocks)

  def rock(self, rock):
    return self._rocks_dict[rock]

  @staticmethod
  def from_ini(filename):
    cfg = ConfigParser()
    cfg.read([filename])
    
    delim = cfg.get("trebuchet", "glyphs.delimiter")
    done_glyphs = cfg.get("trebuchet", "glyphs.done").split(",")

    items = []
    items.extend(cfg.get("trebuchet", "glyphs.in_progress").split(","))
    items.append(delim)
    items.extend(done_glyphs)

    rocks = {}
    rock_keys = cfg.get("trebuchet", "rocks").split(",")
    bad_rocks = [ r for r in rock_keys if not r.startswith("rocks.")]
    if len(bad_rocks) > 0:
      raise Exception("Found improperly named rocks: %s" % bad_rocks)
    for rock in rock_keys:
      rocks[rock] = cfg.get("trebuchet", rock, raw=True)

    return TrebuchetConfig(
        glyphs=items,
        done_glyphs=done_glyphs,
        delim=delim,
        rocks=rock_keys,
        rocks_dict=rocks)


class TrebuchetApp(object):

  def __init__(self, config):
    self.config = config
    pass # ???

  def throw_all(self):
    """
    do something for all the rocks
    """
    pass

  def __rock_watermark(self, rock):
    if rock not in self.config.rocks():
      raise Exception("No such rock: %s" % rock)
    return WatermarkFile(rock + "-last", rock + "-content")

  def throw_rock(self, rock):
    if rock not in self.config.rocks():
      raise Exception("No such rock: %s" % rock)
    rock_format = self.config.rock(rock)
    current = datetime.now().strftime(rock_format)
    
    watermark = self.__rock_watermark(rock)
    if watermark.last() != current:
      trebuchet = None # declare outside of with scope
      if watermark.has_content():
        with watermark.content_filehandle() as file:
          parser = TrebuchetParser(self.config)
          trebuchet = parser.create_from(fileio=file)
          print(trebuchet.str())

        # Compute the new trebuchet
        trebuchet = self.advance_trebuchet(trebuchet)
        print(trebuchet.str())

      watermark.update(current)

      if trebuchet:
        # TODO do something with the trebuchet before filtering it!

        # Now prep the trebuchet for the next iteration.
        trebuchet = trebuchet.filter(lambda glyph: glyph not in self.config.done_glyphs)
        with watermark.content_filehandle() as file:
          file.write(trebuchet.str())
    pass

  def load_rock(self, rock):
    if rock not in self.config.rocks():
      raise Exception("No such rock: %s" % rock)

    watermark = self.__rock_watermark(rock)
    with watermark.content_filehandle() as file:
      parser = TrebuchetParser(self.config)
      return parser.create_from(fileio=file)
    

  def advance_trebuchet(self, node):
    # First reorder the node, then perform complex filtering.
    root = node.reorder(self.config.glyphs)
  
    new_children = [] 

    # copy items that aren't done yet.
    for current in root.children:
      if current.glyph == self.config.delimiter or current.glyph in self.config.done_glyphs:
        # items are sorted, we should see a delimiter first. Baring that, we'll
        # encounter items that are done.
        break
      # Remove items that are done using filter.
      new_children.append(current.filter(
          lambda glyph: glyph not in self.config.done_glyphs))

    # At the end of the previous loop we add a marker
    # to denote the end of the "not done" items.
    new_children.append(
        Trebuchet(
            indent=0,
            line=self.config.delimiter,
            glyph=self.config.delimiter,
            config=self.config))

    # now copy done items.
    for child in root.children:
      # you'd expect that here we'd only keep done items, but we actually
      # have to keep the whole tree leading up to the done things. ie, when a
      # root isn't done, but has some done sub items. We want to keep the sub
      # items. ex:
      #
      # [] not done
      #   * note
      #   [x] done
      # ---
      #
      # becomes
      #
      # [] not done
      #   * note
      # ---
      # [] not done
      #   [x] done
      #
      current = self.copy_done_items(child)
      if current:
        new_children.append(current)

    # we're going to destructively mutate, create a copy.
    root = copy(root)
    root.children = new_children
    return root

  def copy_done_items(self, node):
    # Keep items with a done glyph, and all their sub items.
    if node.glyph in self.config.done_glyphs:
      return node

    # check to see if any of the nodes children make it worth keeping.
    kept_children = []
    for child in node.children:
      copied = self.copy_done_items(child)
      if copied:
        kept_children.append(copied)

    # If this had an item we want to keep as a child, keep it as well.
    if len(kept_children) > 0:
      node = copy(node)
      node.children = kept_children
      return node
    return None


class WatermarkFile(object):
  """
  Class to provide a high watermark of sorts with two files.
  One provides content, the other the monotonic watermark.

  Expected operation order:

  init(mark, content)
  if last() != current_watermark() and has_content():
    with content_filehandle() as file:
      process(file)
    update(current_watermark())

  This assumes the user has some `current_watermark` function.
  """

  def __init__(self, mark_name, content_name):
    self.mark = mark_name
    self.content = content_name

  def last(self):
    """
    Returns the last watermark, or None.
    """
    try:
      with open(self.mark) as file:
        return file.readline().strip()
    except FileNotFoundError:
      return None

  def has_content(self):
    """
    Returns true if the last watermark has content.
    """
    try:
      return os.stat(self.content).st_size > 0
    except FileNotFoundError:
      return False

  def content_filehandle(self):
    """
    Returns an open file object to the content file.

    Is both readable and writeable in byte mode.
    """
    return open(self.content, "r+")

  def update(self, next):
    try:
      os.truncate(self.content, 0)
    except FileNotFoundError:
      pass
    with open(self.mark, "w") as file:
      file.write(next)
      file.write("\n") # be nice to text editors

# various utilities


def count_starting_whitespace(string):
  return len(string) - len(string.lstrip()) 

def strip_terminal_newline(generator):
  for line in generator:
    yield line.rstrip("\n")

if __name__ == "__main__":
  import click
  from configparser import ConfigParser


  @click.option("--config", "-c", default=None)
  def main(config):
    cfg = ConfigParser()
    cfg.read([config])
    pass


  main()
