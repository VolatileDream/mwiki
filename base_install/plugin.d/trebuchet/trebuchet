#!/usr/bin/env python3

from collections import defaultdict
import enum
from copy import copy

class TrebuchetFactory(object):

  def __init__(self):
    self.init = False
    self.glyphs = dict()

  def with_glyph(self, item, has_indent=True):
    """
    Add a glyph to the Trebuchet. Additionally specify if the item 'has indent',
    that is it nests, items 'without indent' only exist on the root level,
    regardless of the amount of indent they may have.

    Items without indent will be stripped of leading whitespace.
    """
    if item in self.glyphs:
      raise Exception("Item '%s' already exists!" % item)
    self.glyphs[item] = has_indent
    return self

  def create_from(self, fileio=None, string=None, string_iterator=None):
    """
    Given either: a file, string, or iterator containing strings, builds
    and returns a Trebuchet object.
    """
    if not self.glyphs:
      raise Exception("Caller didn't specify glyphs!")

    not_none=0
    if fileio is not None:
      not_none += 1
    if string is not None:
      not_none += 1
    if string_iterator is not None:
      not_none += 1
    if not_none != 1:
      raise Exception("createFrom called with too many arguments!")

    if fileio:
      return self.create_from(string_iterator=fileio.readlines())
    if string:
      return self.create_from(string_iterator=string.split("\n"))

    # Hold a permanent reference to the root. The root is special, and has -1
    # indent, to ensure that no other item could possibly have indent equal to
    # it.
    root = Trebuchet(indent=-1, line="", all_glyphs=self.glyphs)

    # The stack of parent Trebuchet items.
    stack = [root]
    for line in string_iterator:
      glyph, has_indent = self.__starting_glyph(line)
      if not glyph:
        if line.strip():
          raise Exception("No glyph specified for: %s" % line)
        else:
          # empty line.
          has_indent=False
          indent = 0
      else:
        if not has_indent:
          line = line.strip()
          indent = 0
        else:
          indent = count_starting_whitespace(line)

      current = Trebuchet(indent=indent, line=line, glyph=glyph, all_glyphs=self.glyphs)

      # this item may need to be placed into the list properly.
      if not has_indent:
        # reset the stack, this item is appended to the root.
        root.add_child(current)
        stack = [root]
      else:
        # this item obeys indent rules. Attempt to get it into the list.
        parent = None
        while True:
          parent = stack[-1]
          print(indent, parent.indent)
          if indent <= parent.indent:
            stack.pop()
          else:
            break
        parent.add_child(current)
        # Assume the next item is beneath this one. If it's not, this will
        # get popped off the stack immediately.
        stack.append(current)

    return root

  def __starting_glyph(self, line):
    line = line.lstrip()
    for key, value in self.glyphs.items():
      if line.startswith(key):
        return (key, value)
    #raise Exception("No glyph specified for: %s" % line)
    return None, None

class Trebuchet(object):
  
  def __init__(self, indent=0, line=None, glyph=None, children=None, all_glyphs=None):
    self.indent = indent
    self.line = line
    self.glyph = glyph
    self.children = children
    if self.children is None:
      self.children = []
    self.all_glyphs = all_glyphs

  def __copy__(self, indent=None, line=None, glyph=None, children=None, all_glyphs=None):
    """
    Implement functionality to use copy.copy, but also
    provide an easy mechanism to change some subfields.
    """
    copy = Trebuchet(
        indent=self.indent,
        line=self.line,
        glyph=self.glyph,
        children=self.children,
        all_glyphs=self.all_glyphs)
    if indent is not None:
      copy.indent = indent
    if line is not None:
      copy.line = line
    if glyph is not None:
      copy.glyph = glyph
    if children is not None:
      copy.children = children
    if all_glyphs is not None:
      copy.all_glyphs = all_glyphs

    return copy

  def add_child(self, child):
    self.children.append(child)

  def reorder(self, ordering):
    """
    Takes a list of glyphs and returns a reordered trebuchet instance.
    """
    glyph_set = set(ordering).symmetric_difference(self.all_glyphs)
    if len(glyph_set) > 0:
      raise Exception(
          "Not all glyphs present in reordering!"
          " reorder must be called with all glyphs from initialization."
          " %s vs %s" % (ordering, set(self.all_glyphs.keys())))
    return self.__reorder(ordering)

  def __reorder(self, ordering):
    reordered_children = defaultdict(lambda: [])
    for child in self.children:
      reordered_children[child.glyph].append(child.__reorder(ordering))
    new_children = []
    for glyph in ordering:
      new_children.extend(reordered_children[glyph])
    return self.__copy__(children=new_children)

  def filter(self, filterfn):
    # TODO: maybe there should be keep/discard/delegate instead?
    #       this potentially allows for keeping done parents w/undone children?
    """
    Accepts a Glpyh predicate function.

    Filters out nodes that do not match the filter, is applied recursively.

    Returns a new Trebuchet instance with the filtering applied.
    """
    # The glyph for this node was checked by its parent, only filter children.
    # Convenient side effect -> root is never checked.
    new_children = []
    for c in self.children:
      if filterfn(c.glyph):
        new_children.append(c.filter(filterfn))
    return self.__copy__(children=new_children)

  def str(self):
    children_repr = "".join([c.str() for c in self.children])
    newline = "\n"
    if self.indent == -1:
      # don't add an extra newline for the root element.
      newline = ""
    return self.line + newline + children_repr

  def __repr__(self):
    children_repr = ",".join([repr(c) for c in self.children])
    newline = ""
    return "Trebuchet(line='" + self.line +"', children=[" + children_repr + "])"


class TrebuchetApp(object):

  def __init__(self, root, misc, in_progress, done):
    self.root = root
    self.misc_glyphs = misc
    self.in_progress_glyphs = in_progress
    self.misc_glyphs_before = True
    self.done_glyphs = done
    pass # ???

  def advance(self):
    pass

  def __glyph_ordering(self):
    glyph_order = []
    if self.misc_glyphs_before:
      glyph_order.extend(self.misc_glyphs)
      glyph_order.extend(self.in_progress_glyphs)
    else:
      glyph_order.extend(self.in_progress_glyphs)
      glyph_order.extend(self.misc_glyphs)
    glyph_order.append("---")
    glyph_order.extend(self.done_glyphs)

    return glyph_order

  def advance_tree(self, node):
    # Setup glyph ordering:
    glyph_order = self.__glyph_ordering()

    # First reorder the node, then perform complex filtering.
    root = node.reorder(glyph_order)
  
    new_children = [] 
    child_iter = iter(root.children) 
    current = None

    # copy items that aren't done yet.
    while True:
      current = next(child_iter)
      if current.glyph == "---":
        break
      # Remove items that are done.
      new_children.append(current.filter(
          lambda glyph: glyph not in self.done_glyphs))

    new_children.append(current)

    # copy done items.

    for child in root.children:
      # you'd expect that here we'd only keep done items, but we actually
      # have to keep the whole tree leading up to the done things. ie, when a
      # root isn't done, but has some done sub items. We want to keep the sub
      # items. ex:
      #
      # [] not done
      #   * note
      #   [x] done
      # ---
      #
      # becomes
      #
      # [] not done
      #   * note
      # ---
      # [] not done
      #   [x] done
      #
      current = self.copy_done_items(child)
      if current:
        new_children.append(current)

    # we're going to destructively mutate, create a copy.
    root = copy(root)
    root.children = new_children
    return root

  def copy_done_items(self, node):
    # Keep items with a done glyph, and all their sub items.
    if node.glyph in self.done_glyphs:
      return node

    # check to see if any of the nodes children make it worth keeping.
    kept_children = []
    for child in node.children:
      copied = self.copy_done_items(child)
      if copied:
        kept_children.append(copied)

    # If this had an item we want to keep as a child, keep it as well.
    if len(kept_children) > 0:
      node = copy(node)
      node.children = kept_children
      return node
    return None
 
# various utilities

def count_starting_whitespace(string):
  return len(string) - len(string.lstrip()) 

