#!/usr/bin/env bash

MWIKI_NAME=".mwiki"
MWIKI_PATH=""

err(){
	echo -e "\e[31m" "$@" "\e[0m" >> /dev/stderr
}

mwiki_require(){
	# set the wiki path and look it up at the same time
	local dir=`lookup $MWIKI_NAME`

	if [ -z "$dir" ]; then
		err "No mwiki wiki was found."
		err "Run: 'mwiki init' to create one."
		exit 1
	fi

	# this will set MWIKI_PATH to be not the empty string
	source "$dir"

	if [ -z "$MWIKI_PATH" ]; then
		err "Bad mwiki instance: $dir"
		exit 1
	else
		if [ "${MWIKI_PATH:0:1}" != "/" ]; then
			# make path relative to project root
			MWIKI_PATH="${dir%$MWIKI_NAME}${MWIKI_PATH}"
		fi
	fi
}

mwiki_gen_plugin(){
	# Setup the base page generation plugin

	mkdir -p "$MWIKI_PATH/plugin.d/base/"

	cat > "$MWIKI_PATH/plugin.d/base/rules" <<- EOF

	# Standard page generation, should probably be replaced with an actual
	# markdown -> html converter.

	# Note that it is mandatory that page parts get added to build/meta/<%B>
	: foreach *.mw |> plugin.d/base/run %f > %o |> build/meta/%B.base build/meta/<%B>

	EOF

	
	cat > "$MWIKI_PATH/plugin.d/base/run" <<- EOF
	(
		echo "<h1> \$1 </h1><hr>"
		# this function is used to generate any sort of markdown/format file
		# to html output.
		cat "\$1" |
		# [#@]			# match a '#' or '@' both are ok
		#     ( [a-zA-Z_0-9]+ )	# capture the part that matters
		sed 's_[#@]\([a-zA-Z_0-9]\+\)_<a href="\1.html">&</a>_g'
	) |
	awk '{ print \$0 "<br>" }'
	EOF
	chmod a+x "$MWIKI_PATH/plugin.d/base/run"
}

mwiki_index_plugin(){

	mkdir -p "$MWIKI_PATH/plugin.d/index/"

	cat > "$MWIKI_PATH/plugin.d/index/rules" <<- EOF

	# this rule MUST go after all plugin generated pages, because tup
	# declarations with wild cards are unfortunately order dependant.

	: *.mw | <html> <meta> |> plugin.d/index/run > %o |> build/#.html

	EOF

	cat > "$MWIKI_PATH/plugin.d/index/run" <<- EOF
	(
		echo "<h1> Meta </h1><hr>"
		# because tup thinks it's so smart by avoiding to count
		# all of the entries as dependencies for the meta file
		# because we never actually open them for reading. So
		# this forces tup to make them our dependencies. :(
		ls 		|
		grep -E 'mw$'	|
		sed 's_.mw\$__'	|
		sort -u |
		while read line ; do
			cat "\$line.mw" > /dev/null
			echo "\$line"
		done |
		sed 's_^.*\$_<a href="&.html">&</a>_'

		echo
		echo "<hr><h1> Generated Pages </h1><hr>"

		# now find the autogenerated pages, same reasoning for
		# the cat > /dev/null as regular pages
		ls "build/" |
		grep -E '^~' |
		while read line ; do
			cat "build/\$line" > /dev/null
			echo "\$line"
		done |
		sed 's_^~\(.*\)\.html\$_<a href="&">\1</a>_'
	) |
	awk '{ print \$0 "<br>" }'
	EOF
	chmod a+x "$MWIKI_PATH/plugin.d/index/run"
}

mwiki_join_plugin(){

	# Setup the join plugin

	mkdir -p "$MWIKI_PATH/plugin.d/join/"

	cat > "$MWIKI_PATH/plugin.d/join/rules" <<- EOF
	
	# these rules are used to join all of the different bits of a page into
	# a single page, it is important that any plugin adds it's parts of
	# generated pages to the build/meta/<%B> group.

	!join = | plugin.d/join/order build/meta/<%B> |> plugin.d/join/run %B > %o |>

	: foreach *.mw |> !join |> build/%B.html <html>

	EOF

	cat > "$MWIKI_PATH/plugin.d/join/run" <<- EOF
	#!/usr/bin/env sh
	entry="\$1" ; shift

	cat plugin.d/join/order |
	while read plugin ; do
		cat "build/meta/\${entry}.\${plugin}"
	done
	EOF
	chmod a+x "$MWIKI_PATH/plugin.d/join/run"

	cat > "$MWIKI_PATH/plugin.d/join/order" <<- EOF
	base
	EOF
}

mwiki_init(){
	if [ $# -lt 1 ]; then
		err "Insufficient arguments to init"
		err "Missing placement directory"
		exit 1
	fi

	local dir="$1" ; shift
	local name="$dir"

	if [ $# -gt 0 ]; then
		name="$1" ; shift
	fi

	local MWIKI_CONF="$dir/$MWIKI_NAME"

	if [ -f "$MWIKI_CONF" ]; then
		err "Wiki already exists: $MWIKI_CONF"
		return 1
	fi

	MWIKI_PATH="$name"

	echo "MWIKI_PATH=$MWIKI_PATH" > "$MWIKI_CONF"

	# create the directory that we're going to build this wiki into at the
	# same time as we build the wiki itself
	mkdir -p "$MWIKI_PATH/build/meta/"

	mwiki_gen_plugin
	mwiki_index_plugin
	mwiki_join_plugin

	touch "$MWIKI_PATH/Tupfile.ini"
	cat > "$MWIKI_PATH/Tupfile"  <<- EOF

	.gitignore

	# The base plugin is used to generate the base page from the wiki entry
	# itself, strictly doing the conversion between wiki syntax and html.
	include plugin.d/base/rules


	include plugin.d/join/rules
	# implementation detail:
	# join expects that plugins will be added to the
	# plugin.d/join/order file, to indicate the order to join the fragments
	# in.

	# other plugins that generate page fragments are expected to conform to
	# the convention that join has setup. This means that fragments should
	# be generated into build/meta/%B.\$plugin-name, as well as adding the
	# fragment to the build/meta/<%B> group. This is the only way the join
	# plugin will find the page fragments.

	# mwiki plugins that autogenerate pages are expected to generate pages
	# that start with a '~', this means that the meta index page will be
	# able to find them all and list them. As well as being put in the 
	# <meta> group to ensure dependencies are correctly ordered.

	include plugin.d/index/rules

	# By convention, the index plugin creates '#.html' which is the default
	# entry point of mwiki.
	EOF
	cat > "$MWIKI_PATH/Tuprules.tup" <<- EOF

	# Never need gitignore
	.gitignore

	# For absolute pathing where required
	ROOT=\$(TUP_CWD)

	EOF
}

mwiki_entries(){
	mwiki_require
	cd "$MWIKI_PATH"
	ls | grep '\.mw$' | sed 's/\.mw$//'
}

mwiki_build(){
	mwiki_require
	if [ $# -gt 0 ]; then
		local ARGS=""
		if [ "$2" = "-a" -o "$2" = "--auto" ]; then
			# have tup auto update things on change
			ARGS="--autoupdate --autoparse"
		fi
		if [ "$1" = "-d" -o "$1" = "--daemon" ]; then
			mwiki_tup monitor --foreground $ARGS
		fi
	else
		mwiki_tup
	fi
}

mwiki_tup(){
	mwiki_require

	# check if tup is running

	local old="$PWD"
	cd "$MWIKI_PATH"
	tup "$@"
	cd "$old"
}

mwiki_edit(){
	mwiki_require
	local entry="$1" ; shift
	local entry_path="$MWIKI_PATH/$entry.mw"

	# we use it as a meta entry later...
	# and no link to it could be created.
	if [ -z "$entry" ]; then
		err "Can't create the empty entry"
		return 1
	fi

	if [ ! -f "$entry_path" ]; then
		read -p "'$entry' doesn't exist, create it? (Y/n) "
		if [ "$REPLY" != "n" -o "$REPLY" != "N" ]; then
			touch "$entry_path"
		fi
	fi

	if [ ! -f "$entry_path" ]; then
		return 1
	fi

	sensible-editor "$entry_path"

	mwiki_tup
}

mwiki_browse(){
	mwiki_require
	cd "$MWIKI_PATH/build/"

	local entry="./#.html"
	if [ $# -gt 0 ]; then
		entry="./$1.html"
	fi

	# use w3m
	w3m "$entry"
}

mwiki(){

	if [ $# -lt 1 ]; then
		mwiki_usage
		exit 1
	fi

	local command="$1" ; shift

	case "$command" in
		init) mwiki_init "$@" ;;
		edit) mwiki_edit "$@" ;;
		entries) mwiki_entries ;;
		browse) mwiki_browse "$@" ;;
		# things for building
		build) mwiki_build "$@" ;;
		*) 
			echo "error: '$command' is not a mwiki command"
			mwiki_usage
			return 1
		;;
	esac
}

mwiki_usage(){
	echo "mwiki <command> ..."
	echo "  init d [n] - initialize a mwiki instance in directory \$d, store it in directory \$n (default to the same as \$d)"
	echo "  edit <n>   - edit the entry called \$n"
	echo "  entries    - list all of the wiki entries"
	echo "  browse <n> - open the wiki entry called \$n"
	echo "  build [-d|--daemon [-a|--auto]] - start a build"
	echo "    -d, --daemon - file monitoring daemon, makes builds faste"
	echo "    -a, --auto - make the daemon rebuild on edits"
}


mwiki "$@"
