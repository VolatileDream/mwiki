#!/usr/bin/env bash

MWIKI_NAME="mwiki.d"
MWIKI_PATH=""

err(){
	echo -e "\e[31m" "$@" "\e[0m" >> /dev/stderr
}

mwiki_require(){
	# set the wiki path and look it up at the same time
	MWIKI_PATH=`lookup $MWIKI_NAME`

	if [ -z "$MWIKI_PATH" ]; then
		err "No mwiki wiki was found."
		err "Run: 'mwiki init' to create one."
		exit 1
	fi
}

mwiki_init(){
	local dir="."

	if [ $# -gt 0 ]; then
		dir="$1" ; shift
	fi

	if [ -d "$dir/$MWIKI_NAME" ]; then
		err "Wiki already exists: $dir/$MWIKI_NAME"
		return 1
	fi

	MWIKI_PATH="$dir/$MWIKI_NAME"

	# create the directory that we're going to build this wiki into at the
	# same time as we build the wiki itself
	mkdir -p "$MWIKI_PATH/build"

	touch "$MWIKI_PATH/Tupfile.ini"

	cat > "$MWIKI_PATH/Tupfile"  <<- EOF

	.gitignore

	!m_build = |> mwiki generate %f %o |> 

	: foreach *.mw |> !m_build |> build/%B.html

	: *.mw |> index++ -e text:* %f |> swish++.index

	# mwiki plugins that autogenerate pages are expected to generate pages
	# that start with a '~', this means that the meta index page will be
	# able to find them all and list them.

	# START MWIKI PLUGINS

	# END MWIKI PLUGINS

	# this rule MUST go after all plugin generated pages, because tup
	# declarations with wild cards are unfortunately order dependant.
	: *.mw | build/~*.html |> mwiki generate '#' %o |> build/#.html

	EOF

}

mwiki_entries(){
	mwiki_require
	cd "$MWIKI_PATH"
	ls | grep '\.mw$' | sed 's/\.mw$//'
}

mwiki_build(){
	mwiki_require
	if [ $# -gt 0 ]; then
		local ARGS=""
		if [ "$2" = "-a" -o "$2" = "--auto" ]; then
			# have tup auto update things on change
			ARGS="--autoupdate --autoparse"
		fi
		if [ "$1" = "-d" -o "$1" = "--daemon" ]; then
			mwiki_tup monitor --foreground $ARGS
		fi
	else
		mwiki_tup
	fi
}

mwiki_tup(){
	mwiki_require

	# check if tup is running

	local old="$PWD"
	cd "$MWIKI_PATH"
	tup "$@"
	cd "$old"
}

mwiki_edit(){
	mwiki_require
	local entry="$1" ; shift
	local entry_path="$MWIKI_PATH/$entry.mw"

	# we use it as a meta entry later...
	# and no link to it could be created.
	if [ -z "$entry" ]; then
		err "Can't create the empty entry"
		return 1
	fi

	if [ ! -f "$entry_path" ]; then
		read -p "'$entry' doesn't exist, create it? (Y/n) "
		if [ "$REPLY" != "n" -o "$REPLY" != "N" ]; then
			touch "$entry_path"
		fi
	fi

	if [ ! -f "$entry_path" ]; then
		return 1
	fi

	sensible-editor "$entry_path"

	mwiki_tup
}

mwiki_gen(){
	mwiki_require
	case "$1" in
		\#)
			echo -e "<h1> Meta </h1><hr>"
			# because tup thinks it's so smart by avoiding to count
			# all of the entries as dependencies for the meta file
			# because we never actually open them for reading. So
			# this forces tup to make them our dependencies. :(
			mwiki_entries | 
			while read line ; do
				cat "$line.mw" > /dev/null
				echo "$line"
			done |
			sed 's_^.*$_<a href="&.html">&</a>_'

			echo -e "<hr><h1> Generated Pages </h1><hr>"

			# now find the autogenerated pages, same reasoning for
			# the cat > /dev/null as regular pages
			ls "build/" |
			grep -E '^~' |
			while read line ; do
				cat "build/$line" > /dev/null
				echo "$line"
			done |
			sed 's_^~\(.*\)\.html$_<a href="&">\1</a>_'
		;;
		*)
			echo -e "<h1> $1 </h1><hr>"
			# this function is used to generate any sort of markdown/format file
			# to html output.
			cat "$1" |
			# [#@]			# match a '#' or '@' both are ok
			#     ( [a-zA-Z_0-9]+ )	# capture the part that matters
			sed 's_[#@]\([a-zA-Z_0-9]\+\)_<a href="\1.html">&</a>_g'
		;;
	esac |
	awk '{ print $0 "<br>" }' |
	cat > "$2"
}

mwiki_browse(){
	mwiki_require
	cd "$MWIKI_PATH/build/"

	local entry="./#.html"
	if [ $# -gt 0 ]; then
		entry="./$1.html"
	fi

	# use w3m
	w3m "$entry"
}

mwiki_search(){
	mwiki_require
	cd "$MWIKI_PATH"

	# use swish++
	search++ "$@"
}

mwiki(){

	if [ $# -lt 1 ]; then
		mwiki_usage
		exit 1
	fi

	local command="$1" ; shift

	case "$command" in
		init) mwiki_init "$@" ;;
		edit) mwiki_edit "$@" ;;
		entries) mwiki_entries ;;
		browse) mwiki_browse "$@" ;;
		search) mwiki_search "$@" ;;
		# things for building
		build) mwiki_build "$@" ;;
		generate) mwiki_gen "$@" ;;
		*) 
			echo "error: '$command' is not a mwiki command"
			mwiki_usage
			return 1
		;;
	esac
}

mwiki_usage(){
	echo "mwiki <command> ..."
	echo "  init [d]   - initialize a mwiki instance in the current director or \$d"
	echo "  edit <n>   - edit the entry called \$n"
	echo "  entries    - list all of the wiki entries"
	echo "  browse <n> - open the wiki entry called \$n"
	echo "  search <s> - invoke swish++ to search for \$s"
	echo "  generate <i> <o> - run file generation for \$i and output to \$o"
	echo "  build [-d|--daemon [-a|--auto]] - start a build"
	echo "    -d, --daemon - file monitoring daemon, makes builds faste"
	echo "    -a, --auto - make the daemon rebuild on edits"
}


mwiki "$@"
