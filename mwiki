#!/usr/bin/env bash

MWIKI_NAME=".mwiki"

err(){
	echo -e "\e[31m" "$@" "\e[0m" >> /dev/stderr
}

mwiki_require(){
	# Path already set.
	if [ -n "$MWIKI_PATH" ]; then
		return 0
	fi
	# set the wiki path and look it up at the same time
	local dir=`lookup $MWIKI_NAME`

	if [ -z "$dir" ]; then
		err "No mwiki wiki was found."
		err "Run: 'mwiki init' to create one."
		exit 1
	fi

	# this will set MWIKI_PATH to be not the empty string
	source "$dir"

	if [ -z "$MWIKI_PATH" ]; then
		err "Bad mwiki instance: $dir"
		exit 1
	else
		if [ "${MWIKI_PATH:0:1}" != "/" ]; then
			# make path relative to project root
			MWIKI_PATH="${dir%$MWIKI_NAME}${MWIKI_PATH}"
		fi
	fi
}

mwiki_init(){
	if [ $# -lt 1 ]; then
		err "Insufficient arguments to init"
		err "Missing placement directory"
		exit 1
	fi

	local dir="$1" ; shift
	local name="$dir"

	if [ $# -gt 0 ]; then
		name="$1" ; shift
	fi

	local MWIKI_CONF="$dir/$MWIKI_NAME"

	if [ -f "$MWIKI_CONF" ]; then
		err "Wiki already exists: $MWIKI_CONF"
		return 1
	fi

	MWIKI_PATH="$name"

	mkdir -p "$MWIKI_PATH"

	echo "MWIKI_PATH=$MWIKI_PATH" > "$MWIKI_CONF"

	echo "Please download http://github.com/volatiledream/mwiki/blob/master/base.zip and"
	echo " extract it into '$MWIKI_PATH'."
}

mwiki_entries(){
	mwiki_require
	cd "$MWIKI_PATH/entries"
	ls | grep '\.mw$' | sed 's/\.mw$//'
}

mwiki_build(){
	mwiki_require

	local -a ARGS

	while [ $# -gt 0 ]; do
		case $1 in
			-a|--auto)
				ARGS+=("--autoupdate")
				ARGS+=("--autoparse")
				;;
			-d|--daemon)
				ARGS+=("monitor")
				ARGS+=("foreground")
				;;
			# unrecognized arguments are just passed through
			*) ARGS+=("$1") ;;
		esac
		shift
	done

	mwiki_tup "${ARGS[@]}"
}

mwiki_tup(){
	mwiki_require

	# check if tup is running

	local old="$PWD"
	cd "$MWIKI_PATH"
	tup "$@"
	cd "$old"
}

mwiki_edit(){
	mwiki_require
	local entry="$1" ; shift
	local entry_path="$MWIKI_PATH/entries/$entry.mw"

	# we use it as a meta entry later...
	# and no link to it could be created.
	if [ -z "$entry" ]; then
		err "Can't create the empty entry"
		return 1
	fi

    # used for a hack around tup behaviour
	local created=0

	# check if std in is a tty
	if ! tty > /dev/null ; then
		[ -f "$entry_path" ] || created=1
		cat >> "$entry_path"
	else
		if [ ! -f "$entry_path" ]; then
			read -p "'$entry' doesn't exist, create it? (Y/n) "
			if [ "$REPLY" != "n" -a "$REPLY" != "N" ]; then
				touch "$entry_path"
				created=1
			fi
		fi

		if [ ! -f "$entry_path" ]; then
			return 1
		fi

        # This makes it really nice to open other entries while editing.
        local old_path="$PWD"
        cd "${MWIKI_PATH}/entries/"
        sensible-editor "${entry}.mw"
        cd "$old_path"
    fi

	# this is an ugly hack to deal with tup incorrectly updating #.html
	if [ $created -eq 1 ]; then
		rm "${MWIKI_PATH}/build/#.html" "${MWIKI_PATH}/build/~*"
	fi

	mwiki_tup
}

mwiki_browse(){
	mwiki_require
	cd "$MWIKI_PATH/build/"

	local entry="./#.html"
	if [ $# -gt 0 ]; then
		entry="./$1.html"
	fi

	# use w3m
	w3m "$entry"
}

mwiki(){

	if [ $# -lt 1 ]; then
		mwiki_usage
		exit 1
	fi

	local command="$1" ; shift

	case "$command" in
		init) mwiki_init "$@" ;;
		edit) mwiki_edit "$@" ;;
		entries) mwiki_entries ;;
		browse) mwiki_browse "$@" ;;
		# things for building
		build) mwiki_build "$@" ;;
		*) 
			echo "error: '$command' is not a mwiki command"
			mwiki_usage
			return 1
		;;
	esac
}

mwiki_usage(){
	echo "mwiki <command> ..."
	echo "  init d [n] - initialize a mwiki instance in directory \$d, store it in directory \$n (default to the same as \$d)"
	echo "  edit <n>   - edit the entry called \$n"
	echo "  entries    - list all of the wiki entries"
	echo "  browse <n> - open the wiki entry called \$n"
	echo "  build [-d|--daemon [-a|--auto]] - start a build"
	echo "    -d, --daemon - file monitoring daemon, makes builds faste"
	echo "    -a, --auto - make the daemon rebuild on edits"
}

mwiki "$@"
