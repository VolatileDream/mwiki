#!/usr/bin/env bash

MWIKI_NAME=".mwiki"

err(){
	echo -e "\e[31m" "$@" "\e[0m" >> /dev/stderr
}

mwiki_require(){
	# Path already set.
	if [ -n "$MWIKI_PATH" ]; then
		return 0
	fi
	# set the wiki path and look it up at the same time
	local dir=`lookup $MWIKI_NAME`

	if [ -z "$dir" ]; then
		err "No mwiki wiki was found."
		err "Run: 'mwiki init' to create one."
		exit 1
	fi

	# this will set MWIKI_PATH to be not the empty string
	source "$dir"

	if [ -z "$MWIKI_PATH" ]; then
		err "Bad mwiki instance: $dir"
		exit 1
	else
		if [ "${MWIKI_PATH:0:1}" != "/" ]; then
			# make path relative to project root
			MWIKI_PATH="${dir%$MWIKI_NAME}${MWIKI_PATH}"
		fi
	fi
}

mwiki_init(){
	if [ $# -lt 1 ]; then
		err "Insufficient arguments to init"
		err "Missing placement directory"
		exit 1
	fi

	local dir="$1" ; shift
	local name="$dir"

	if [ $# -gt 0 ]; then
		name="$1" ; shift
	fi

	local MWIKI_CONF="$dir/$MWIKI_NAME"

	if [ -f "$MWIKI_CONF" ]; then
		err "Wiki already exists: $MWIKI_CONF"
		return 1
	fi

	MWIKI_PATH="$name"

	# create the directory that we're going to build this wiki into at the
	# same time as we build the wiki itself
	mkdir -p "$MWIKI_PATH/build/"
	mkdir -p "$MWIKI_PATH/partial/"

	touch "$MWIKI_PATH/Tupfile.ini"

	echo "MWIKI_PATH=$MWIKI_PATH" > "$MWIKI_CONF"

	cat > "$MWIKI_PATH/Tuprules.tup" <<- EOF
	PARTIAL=partial
	ENTRIES=entries
	OUTPUT=build
	EOF
	cat > "$MWIKI_PATH/Tupfile"  <<- EOF
	include_rules

	ifeq (\$PARTIAL,)
		error PARTIAL was not defined.
	endif
	ifeq (\$OUTPUT,)
		error OUTPUT was not defined.
	endif
	ifeq (\$ENTRIES,)
		error ENTRIES was not defined.
	endif

	# plugins that generate page fragments are expected to conform to
	# the convention that join has setup. This means that fragments should
	# be generated into \$PARTIAL/%B.\$plugin-name, as well as adding the
	# fragment to the \$PARTIAL/<%B> group. This is the only way the join
	# plugin will find the page fragments.

	# mwiki plugins that autogenerate pages are expected to generate pages
	# that start with a '~', this means that the meta index page will be
	# able to find them all and list them. As well as being put in the 
	# <meta> group to ensure dependencies are correctly ordered.

	include plugin.d/join/rules
	# implementation detail:
	# join expects that plugins will be added to the
	# plugin.d/join/order file, to indicate the order to join the fragments
	# in.

	# By convention, the index plugin creates '#.html' which is the default
	# entry point of mwiki.
	include plugin.d/index/rules

	# The base plugin is used to generate the base page from the wiki entry
	# itself, strictly doing the conversion between wiki syntax and html.
	# It expects files that end with .mw in \$PARTIAL/, and converts them.
	include plugin.d/base/rules
	EOF
}

mwiki_entries(){
	mwiki_require
	cd "$MWIKI_PATH/entries"
	ls | grep '\.mw$' | sed 's/\.mw$//'
}

mwiki_build(){
	mwiki_require

	local -a ARGS
	local index=0

	while [ $# -gt 0 ]; do
		case $1 in
			-a|--auto)
				ARGS[$index]="--autoupdate"
				index=$((index+1))
				ARGS[$index]="--autoparse"
				;;
			-d|--daemon)
				ARGS[$index]="monitor"
				index=$((index+1))
				ARGS[$index]="foreground"
				;;
			# unrecognized arguments are just passed through
			*) ARGS[$index]="$1" ;;
		esac
		index=$((index+1))
		shift
	done

	mwiki_tup ${ARGS[@]}
}

mwiki_tup(){
	mwiki_require

	# check if tup is running

	local old="$PWD"
	cd "$MWIKI_PATH"
	tup "$@"
	cd "$old"
}

mwiki_edit(){
	mwiki_require
	local entry="$1" ; shift
	local entry_path="$MWIKI_PATH/entries/$entry.mw"

	# we use it as a meta entry later...
	# and no link to it could be created.
	if [ -z "$entry" ]; then
		err "Can't create the empty entry"
		return 1
	fi

	# check if std in is a tty
	if ! tty > /dev/null ; then
		cat >> "$entry_path"
	else
		if [ ! -f "$entry_path" ]; then
			read -p "'$entry' doesn't exist, create it? (Y/n) "
			if [ "$REPLY" != "n" -a "$REPLY" != "N" ]; then
				touch "$entry_path"
			fi
		fi

		if [ ! -f "$entry_path" ]; then
			return 1
		fi

		sensible-editor "$entry_path"
	fi


	mwiki_tup
}

mwiki_browse(){
	mwiki_require
	cd "$MWIKI_PATH/build/"

	local entry="./#.html"
	if [ $# -gt 0 ]; then
		entry="./$1.html"
	fi

	# use w3m
	w3m "$entry"
}

mwiki(){

	if [ $# -lt 1 ]; then
		mwiki_usage
		exit 1
	fi

	local command="$1" ; shift

	case "$command" in
		init) mwiki_init "$@" ;;
		edit) mwiki_edit "$@" ;;
		entries) mwiki_entries ;;
		browse) mwiki_browse "$@" ;;
		# things for building
		build) mwiki_build "$@" ;;
		*) 
			echo "error: '$command' is not a mwiki command"
			mwiki_usage
			return 1
		;;
	esac
}

mwiki_usage(){
	echo "mwiki <command> ..."
	echo "  init d [n] - initialize a mwiki instance in directory \$d, store it in directory \$n (default to the same as \$d)"
	echo "  edit <n>   - edit the entry called \$n"
	echo "  entries    - list all of the wiki entries"
	echo "  browse <n> - open the wiki entry called \$n"
	echo "  build [-d|--daemon [-a|--auto]] - start a build"
	echo "    -d, --daemon - file monitoring daemon, makes builds faste"
	echo "    -a, --auto - make the daemon rebuild on edits"
}


mwiki "$@"
